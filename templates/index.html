<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Video Scorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Favicon: small movie camera emoji as SVG data URI -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><text y='50%' x='50%' text-anchor='middle' dominant-baseline='central' font-size='48'>üé¨</text></svg>">
  <link rel="stylesheet" href="/themes/style_default.css">
  <style>
    /* Simple spinner animation */
    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      vertical-align: middle;
      border: 2px solid #ccc;
      border-top: 2px solid #333;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
      margin-left: 6px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Toggle button styles */
    .toggle-container {
      display: flex;
      gap: 4px;
      align-items: center;
    }
    
    .toggle-btn {
      padding: 4px 8px;
      border: 1px solid #666;
      background: #333;
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      text-transform: uppercase;
      min-width: 35px;
      text-align: center;
      transition: all 0.2s ease;
    }
    
    .toggle-btn.active {
      background: #4CAF50;
      border-color: #45a049;
      color: white;
    }
    
    .toggle-btn.inactive {
      background: #555;
      border-color: #444;
      color: #999;
      opacity: 0.6;
    }
    
    .toggle-btn:hover {
      opacity: 0.8;
    }
    
    .refresh-btn {
      padding: 6px 8px;
      border: 1px solid #666;
      background: #333;
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .refresh-btn:hover {
      background: #444;
    }
    
    /* Collapsible toolbar styles */
    .toolbar-toggle {
      position: fixed;
      top: 8px;
      right: 8px;
      z-index: 1000;
      background: #333;
      color: #fff;
      border: 1px solid #666;
      border-radius: 4px;
      padding: 6px 8px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s ease;
    }
    
    .toolbar-toggle:hover {
      background: #444;
    }
    
    .toolbar-container {
      transition: all 0.3s ease;
      overflow: visible;
    }
    
    .toolbar-container.collapsed {
      max-height: 0;
      opacity: 0;
      margin: 0;
      padding: 0;
    }
    
    .toolbar-container.collapsed header {
      margin: 0;
      padding: 0;
    }
    
    .toolbar-container.collapsed .toolbar-rows {
      display: none;
    }
    
    /* Adjust body spacing when toolbar is collapsed */
    body.toolbar-collapsed main {
      padding-top: 8px;
      transition: padding-top 0.3s ease;
    }

    /* Directory navigation buttons */
    .nav-btn {
      background: #2f2f2f;
      color: #eee;
      border: 1px solid #666;
      padding: 8px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 32px;
      height: 32px;
    }
    .nav-btn:hover {
      background: #3a3a3a;
    }

    /* Directory dropdown */
    .dir-dropdown-container {
      position: relative;
    }
    .dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      background: #2f2f2f;
      border: 1px solid #666;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      min-width: 200px;
      max-height: 300px;
      overflow-y: auto;
      margin-top: 2px;
    }
    .dropdown-item {
      padding: 8px 12px;
      cursor: pointer;
      color: #eee;
      border-bottom: 1px solid #444;
    }
    .dropdown-item:hover {
      background: #3a3a3a;
    }
    .dropdown-item:last-child {
      border-bottom: none;
    }
    .dropdown-empty {
      padding: 8px 12px;
      color: #999;
      font-style: italic;
    }
    
    /* Directory input with triangle dropdown */
    .dir-input-container {
      position: relative;
    }
    .dir-triangle-btn {
      position: absolute;
      right: 4px;
      top: 50%;
      transform: translateY(-50%);
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 4px 6px;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.7;
      transition: all 0.2s ease;
    }
    .dir-triangle-btn:hover {
      background: #3a3a3a;
      opacity: 1;
    }
    .dir-triangle-btn svg {
      pointer-events: none;
    }
  </style>
</head>
<body>
  <button class="toolbar-toggle" id="toolbar-toggle" title="Toggle Toolbar">‚åÑ</button>
  <div class="toolbar-container" id="toolbar-container">
    <header>
      <h1>üé¨ Video/Image Scorer (FastAPI)</h1>
      <div class="pill">Keys: ‚Üê/‚Üí navigate ‚Ä¢ Space play/pause (video) ‚Ä¢ 1‚Äì5 rate ‚Ä¢ R reject ‚Ä¢ C clear ‚Ä¢ Esc exit maximized</div>
    </header>
    <div class="toolbar-rows">
      <div class="row">
        <button id="dir_up" class="nav-btn" title="Go up one directory">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 15l-6-6-6 6"/>
          </svg>
        </button>
        <div class="dir-dropdown-container">
          <button id="dir_browse" class="nav-btn" title="Browse directories">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
            </svg>
          </button>
          <div id="dir_dropdown" class="dropdown-menu" style="display: none;"></div>
        </div>
        <div class="dir-input-container" style="position: relative;">
          <input id="dir" type="text" style="min-width:200px; max-width:400px; width:400px; padding-right:30px;" placeholder="/path/to/folder"/>
          <button id="dir_siblings" class="dir-triangle-btn" title="Browse sibling directories">
            <svg width="12" height="8" viewBox="0 0 12 8" fill="white">
              <path d="M6 8L0 0h12z"/>
            </svg>
          </button>
          <div id="dir_siblings_dropdown" class="dropdown-menu" style="display: none;"></div>
        </div>
        <div id="toggle_buttons" class="toggle-container"></div>
        <input id="pattern" type="text" style="min-width:180px" placeholder="glob pattern (e.g. *.mp4|*.png|*.jpg)" />
        <button id="pat_help" class="helpbtn">?</button>
        <button id="load" class="refresh-btn" title="Load/Refresh">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
            <path d="M21 3v5h-5"/>
            <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
            <path d="M3 21v-5h5"/>
          </svg>
        </button>
        <div id="dir_display" class="filename"></div>
      </div>
      <div class="row">
        <label for="min_filter">Rating ‚â•</label>
        <select id="min_filter">
          <option value="none" selected>No filter</option>
          <option value="unrated">Unrated</option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
        </select>
        <div id="filter_info" class="filename"></div>
        <div class="controls">
          <button id="prev">Prev</button>
          <button id="next">Next</button>
          <button id="reject">Reject</button>
          <button id="clear">Clear</button>
          <button data-star="1">‚òÖ1</button>
          <button data-star="2">‚òÖ2</button>
          <button data-star="3">‚òÖ3</button>
          <button data-star="4">‚òÖ4</button>
          <button data-star="5">‚òÖ5</button>
          <button id="extract_one">Extract workflow (current)</button>
          <button id="extract_filtered">Extract workflows (filtered)</button>
          <button id="download_btn" title="Download current">
            <!-- Download icon SVG -->
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
              <path d="M12 3v12m0 0l-5-5m5 5l5-5M5 19h14" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
  </div>
  <main class="layout">
    <aside id="sidebar">
      <div id="sidebar_controls" style="display:none;">
        <div class="button-row">
          <button id="toggle_thumbnails" class="pill">Toggle Thumbnails</button>
          <button id="export_filtered_btn" class="pill" title="Export all filtered files as ZIP">
            <!-- ZIP folder icon SVG -->
            <svg width="16" height="12" viewBox="0 0 24 24" fill="none" style="margin-right: 2px;">
              <path d="M16 22H8C6.9 22 6 21.1 6 20V4C6 2.9 6.9 2 8 2H14L18 6V20C18 21.1 17.1 22 16 22Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M14 2V6H18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M10 12H14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M10 16H14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            Export Filtered
          </button>
        </div>
        <div style="margin-top: 4px;">
          <span id="progress_status" style="font-size: 12px; opacity: 0.8; display: none;"></span>
        </div>
      </div>
      <div id="sidebar_list"></div>
    </aside>
    <section id="right">
      <div class="row">
        <div class="filename" id="filename">(loading‚Ä¶)</div>
      </div>
      <div class="row">
        <div class="video-wrap">
          <div class="overlay-top-left" id="pnginfo_controls" style="display:none;">
            <div class="overlay-btn" id="pnginfo_btn" title="Show info">i</div>
          </div>
          <div id="pnginfo_panel">
            <button id="pnginfo_copy" title="Copy all">Copy</button>
            <div id="pnginfo_text"></div>
          </div>
          <video id="player" width="960" height="540" controls preload="metadata" style="display:none"></video>
          <img id="imgview" style="max-width:960px; max-height:540px; display:none" />
          <div class="scorebar" id="scorebar"></div>
        </div>
      </div>
    </section>
  </main>
<script>
// Toolbar collapse functionality
let toolbarCollapsed = false;

function toggleToolbar() {
  const container = document.getElementById('toolbar-container');
  const toggleBtn = document.getElementById('toolbar-toggle');
  const body = document.body;
  
  toolbarCollapsed = !toolbarCollapsed;
  
  if (toolbarCollapsed) {
    container.classList.add('collapsed');
    body.classList.add('toolbar-collapsed');
    toggleBtn.textContent = '‚åÉ';
    toggleBtn.title = 'Show Toolbar';
  } else {
    container.classList.remove('collapsed');
    body.classList.remove('toolbar-collapsed');
    toggleBtn.textContent = '‚åÑ';
    toggleBtn.title = 'Hide Toolbar';
  }
}

// Add toolbar toggle event listener
document.addEventListener('DOMContentLoaded', function() {
  const toggleBtn = document.getElementById('toolbar-toggle');
  if (toggleBtn) {
    toggleBtn.addEventListener('click', toggleToolbar);
  }
});

let videos = [];
let filtered = [];
let idx = 0;
let currentDir = "";
let currentPattern = "*.mp4";
let minFilter = null; // null means no filter; otherwise 1..5
let thumbnailsEnabled = false;
let thumbnailHeight = 64;
let isMaximized = false;
let showThumbnails = true; // user preference for showing thumbnails
let toggleExtensions = ["jpg", "png", "mp4"]; // configurable extensions for toggle buttons

// Thumbnail progress tracking
let thumbnailProgressInterval = null;

// Progress status management functions
function showProgress(message) {
  const statusElement = document.getElementById('progress_status');
  if (statusElement) {
    statusElement.style.display = 'inline';
    statusElement.innerHTML = `${message} <span class="spinner"></span>`;
  }
}

function hideProgress() {
  const statusElement = document.getElementById('progress_status');
  if (statusElement) {
    statusElement.style.display = 'none';
    statusElement.innerHTML = '';
  }
}

// Toggle button functionality
function initializeToggleButtons() {
  const container = document.getElementById('toggle_buttons');
  if (!container) return;
  
  container.innerHTML = '';
  
  toggleExtensions.forEach(ext => {
    const btn = document.createElement('button');
    btn.className = 'toggle-btn';
    btn.textContent = ext.toUpperCase();
    btn.dataset.extension = ext;
    btn.onclick = () => toggleExtension(ext);
    container.appendChild(btn);
  });
  
  // Update button states based on current pattern
  updateToggleButtonStates();
  
  // Add pattern input listener
  const patternInput = document.getElementById('pattern');
  if (patternInput) {
    patternInput.addEventListener('input', updateToggleButtonStates);
  }
}

function toggleExtension(extension) {
  const patternInput = document.getElementById('pattern');
  if (!patternInput) return;
  
  const currentPattern = patternInput.value.trim();
  const extPattern = `*.${extension}`;
  
  let newPattern;
  if (isExtensionInPattern(extension, currentPattern)) {
    // Remove the extension
    newPattern = removeExtensionFromPattern(extension, currentPattern);
  } else {
    // Add the extension
    newPattern = addExtensionToPattern(extension, currentPattern);
  }
  
  patternInput.value = newPattern;
  updateToggleButtonStates();
}

function isExtensionInPattern(extension, pattern) {
  const extPattern = `*.${extension}`;
  return pattern.split('|').some(part => part.trim() === extPattern);
}

function removeExtensionFromPattern(extension, pattern) {
  const extPattern = `*.${extension}`;
  const parts = pattern.split('|').map(p => p.trim()).filter(p => p !== extPattern);
  return parts.length > 0 ? parts.join('|') : '*.mp4';
}

function addExtensionToPattern(extension, pattern) {
  const extPattern = `*.${extension}`;
  if (!pattern.trim()) {
    return extPattern;
  }
  
  const parts = pattern.split('|').map(p => p.trim()).filter(p => p && p !== extPattern);
  parts.push(extPattern);
  return parts.join('|');
}

function updateToggleButtonStates() {
  const patternInput = document.getElementById('pattern');
  if (!patternInput) return;
  
  const currentPattern = patternInput.value.trim();
  
  toggleExtensions.forEach(ext => {
    const btn = document.querySelector(`[data-extension="${ext}"]`);
    if (btn) {
      if (isExtensionInPattern(ext, currentPattern)) {
        btn.className = 'toggle-btn active';
      } else {
        btn.className = 'toggle-btn inactive';
      }
    }
  });
}

function updateThumbnailStatus() {
  fetch('/api/thumbnail-progress')
    .then(r => r.json())
    .then(progress => {
      if (progress.generating && progress.total > 0) {
        showProgress(`Generating thumbnails (${progress.current}/${progress.total})`);
        // Start polling if not already started
        if (!thumbnailProgressInterval) {
          thumbnailProgressInterval = setInterval(updateThumbnailStatus, 500);
        }
      } else {
        hideProgress();
        // Stop polling when done
        if (thumbnailProgressInterval) {
          clearInterval(thumbnailProgressInterval);
          thumbnailProgressInterval = null;
        }
      }
    })
    .catch(() => {
      // Hide progress on error
      hideProgress();
      // Stop polling on error
      if (thumbnailProgressInterval) {
        clearInterval(thumbnailProgressInterval);
        thumbnailProgressInterval = null;
      }
    });
}

let currentMeta = null;
function togglePngInfo(show){
  const panel = document.getElementById('pnginfo_panel');
  if (!panel) return;
  if (show === undefined){ panel.style.display = (panel.style.display==='none' || panel.style.display==='') ? 'block' : 'none'; }
  else { panel.style.display = show ? 'block' : 'none'; }
}
function setupPngInfo(meta, name){
  currentMeta = meta || null;
  const controls = document.getElementById('pnginfo_controls');
  const textDiv = document.getElementById('pnginfo_text');
  togglePngInfo(false);
  if (meta && meta.png_text && isImageName(name) && name.toLowerCase().endsWith('.png')){
    controls.style.display = 'flex';
    textDiv.textContent = meta.png_text;
  } else {
    controls.style.display = 'none';
    textDiv.textContent = '';
  }
}
document.addEventListener('click', (e)=>{
  if (e.target && e.target.id === 'pnginfo_btn'){ 
    togglePngInfo();   // <-- toggles open/close
  }
  if (e.target && e.target.id === 'pnginfo_copy'){ 
    const text = (document.getElementById('pnginfo_text').textContent)||'';
    if (!navigator.clipboard){ 
      const ta = document.createElement('textarea'); 
      ta.value = text; 
      document.body.appendChild(ta); 
      ta.select(); 
      document.execCommand('copy'); 
      document.body.removeChild(ta);
    } else {
      navigator.clipboard.writeText(text).catch(()=>{});
    }
  }
  if (e.target && e.target.id === 'toggle_thumbnails'){ 
    showThumbnails = !showThumbnails;
    renderSidebar();
  }
});

function toggleMaximize(){
  const videoWrap = document.querySelector('.video-wrap');
  const player = document.getElementById('player');
  const imgview = document.getElementById('imgview');
  const maximizeBtn = document.getElementById('maximize-btn');
  
  if (!videoWrap || !maximizeBtn) return;
  
  isMaximized = !isMaximized;
  
  if (isMaximized) {
    // Calculate available space
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // Get current media dimensions
    let mediaWidth, mediaHeight;
    if (player && player.style.display !== 'none') {
      mediaWidth = player.videoWidth || 960;
      mediaHeight = player.videoHeight || 540;
    } else if (imgview && imgview.style.display !== 'none') {
      mediaWidth = imgview.naturalWidth || 960;
      mediaHeight = imgview.naturalHeight || 540;
    } else {
      mediaWidth = 960;
      mediaHeight = 540;
    }
    
    // Calculate scale to fit screen while maintaining aspect ratio
    const scaleX = (viewportWidth - 32) / mediaWidth; // 32px for padding
    const scaleY = (viewportHeight - 120) / mediaHeight; // 120px for UI elements
    const scale = Math.min(scaleX, scaleY, 3); // Cap at 3x zoom
    
    // Apply maximized styles
    videoWrap.style.position = 'fixed';
    videoWrap.style.top = '50%';
    videoWrap.style.left = '50%';
    videoWrap.style.transform = 'translate(-50%, -50%)';
    videoWrap.style.zIndex = '1000';
    videoWrap.style.background = '#000';
    videoWrap.style.maxWidth = 'none';
    videoWrap.style.maxHeight = 'none';
    
    if (player && player.style.display !== 'none') {
      player.style.width = (mediaWidth * scale) + 'px';
      player.style.height = (mediaHeight * scale) + 'px';
      player.style.maxWidth = 'none';
      player.style.maxHeight = 'none';
    }
    
    if (imgview && imgview.style.display !== 'none') {
      imgview.style.width = (mediaWidth * scale) + 'px';
      imgview.style.height = (mediaHeight * scale) + 'px';
      imgview.style.maxWidth = 'none';
      imgview.style.maxHeight = 'none';
    }
    
    // Update button icon and title
    maximizeBtn.innerHTML = svgMinimize();
    maximizeBtn.title = 'Return to actual size';
    
    // Add backdrop
    const backdrop = document.createElement('div');
    backdrop.id = 'maximize-backdrop';
    backdrop.style.position = 'fixed';
    backdrop.style.top = '0';
    backdrop.style.left = '0';
    backdrop.style.width = '100%';
    backdrop.style.height = '100%';
    backdrop.style.backgroundColor = 'rgba(0,0,0,0.8)';
    backdrop.style.zIndex = '999';
    backdrop.addEventListener('click', toggleMaximize);
    document.body.appendChild(backdrop);
    
  } else {
    // Reset to normal size
    videoWrap.style.position = '';
    videoWrap.style.top = '';
    videoWrap.style.left = '';
    videoWrap.style.transform = '';
    videoWrap.style.zIndex = '';
    videoWrap.style.background = '';
    videoWrap.style.maxWidth = '';
    videoWrap.style.maxHeight = '';
    
    if (player && player.style.display !== 'none') {
      player.style.width = '960px';
      player.style.height = '540px';
      player.style.maxWidth = '';
      player.style.maxHeight = '';
    }
    
    if (imgview && imgview.style.display !== 'none') {
      imgview.style.width = '';
      imgview.style.height = '';
      imgview.style.maxWidth = '960px';
      imgview.style.maxHeight = '540px';
    }
    
    // Update button icon and title
    maximizeBtn.innerHTML = svgMaximize();
    maximizeBtn.title = 'Maximize media';
    
    // Remove backdrop
    const backdrop = document.getElementById('maximize-backdrop');
    if (backdrop) backdrop.remove();
  }
}

function updateDownloadButton(name){
  const db = document.getElementById('download_btn');
  if (!db) return;
  if (!name){ db.disabled = true; return; }
  db.disabled = false;
  db.onclick = () => {
    try { window.location.href = '/download/' + encodeURIComponent(name); }
    catch(e){ alert('Download failed to start: ' + e); }
  };
}

function svgReject(selected){
  const circleFill = selected ? "var(--reject-fill-selected)" : "var(--reject-fill-unselected)";
  const xColor = selected ? "var(--reject-x-selected)" : "var(--reject-x-unselected)";
  const r = 16, cx=20, cy=20;
  return `
<svg width="40" height="40" viewBox="0 0 40 40">
  <circle cx="${cx}" cy="${cy}" r="${r}" fill="${circleFill}" stroke="var(--reject-stroke-color)" stroke-width="2" />
  <line x1="${cx-10}" y1="${cy-10}" x2="${cx+10}" y2="${cy+10}" stroke="${xColor}" stroke-width="4" stroke-linecap="round" />
  <line x1="${cx-10}" y1="${cy+10}" x2="${cx+10}" y2="${cy-10}" stroke="${xColor}" stroke-width="4" stroke-linecap="round" />
</svg>`;
}
function svgStar(filled){
  const fill = filled ? "var(--star-fill-selected)" : "var(--star-fill-unselected)";
  return `
<svg width="40" height="40" viewBox="0 0 40 40">
  <polygon points="20,4 24,16 36,16 26,24 30,36 20,28 10,36 14,24 4,16 16,16"
    fill="${fill}" stroke="var(--star-stroke-color)" stroke-width="2"/>
</svg>`;
}
function svgMaximize(){
  return `
<svg width="24" height="24" viewBox="0 0 24 24" fill="none">
  <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;
}
function svgMinimize(){
  return `
<svg width="24" height="24" viewBox="0 0 24 24" fill="none">
  <path d="M4 14h6m0 0v6m0-6l-7 7m17-11h-6m0 0V4m0 6l7-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;
}
function renderScoreBar(score){
  const bar = document.getElementById("scorebar");
  let html = `<div style="display:flex; gap:8px; align-items:center; justify-content:space-between;">`;
  html += `<div style="display:flex; gap:8px; align-items:center;">`;
  html += svgReject(score === -1);
  const stars = (score === -1) ? 0 : Math.max(0, score||0);
  for (let i=0;i<5;i++) html += svgStar(i<stars);
  html += `</div>`;
  html += `<button id="maximize-btn" class="maximize-btn" title="${isMaximized ? 'Return to actual size' : 'Maximize media'}">`;
  html += isMaximized ? svgMinimize() : svgMaximize();
  html += `</button>`;
  html += `</div>`;
  bar.innerHTML = html;
  
  // Attach event listener to the new button
  const maximizeBtn = document.getElementById('maximize-btn');
  if (maximizeBtn) {
    maximizeBtn.addEventListener('click', toggleMaximize);
  }
}
function scoreBadge(s){
  if (s === -1) return 'R';
  if (!s || s < 1) return '‚Äî';
  return s + '‚òÖ';
}
function renderSidebar(){
  const list = document.getElementById('sidebar_list');
  if (!list) return;
  let html = '';
  const namesInFiltered = new Set(filtered.map(v => v.name));
  videos.forEach((v) => {
    const inFiltered = namesInFiltered.has(v.name);
    const s = scoreBadge(v.score || 0);
    const classes = ['item'];
    if (!inFiltered) classes.push('disabled');
    if (filtered.length && filtered[idx] && filtered[idx].name === v.name) classes.push('current');
    
    let thumbHtml = '';
    if (thumbnailsEnabled && showThumbnails) {
      thumbHtml = `<div class="thumbnail"><img src="/thumbnail/${encodeURIComponent(v.name)}" alt="" style="height:${thumbnailHeight}px" onerror="this.style.display='none'"></div>`;
      classes.push('with-thumbnails');
    }
    
    html += `<div class="${classes.join(' ')}" data-name="${v.name}" ${inFiltered ? '' : 'data-disabled="1"'}>` +
            thumbHtml +
            `<div class="content">` +
            `<div class="name" title="${v.name}">${v.name}</div>` +
            `<div class="score">${s}</div>` +
            `</div>` +
            `</div>`;
  });
  list.innerHTML = html;
  list.querySelectorAll('.item').forEach(el => {
    if (el.getAttribute('data-disabled') === '1') return;
    el.addEventListener('click', () => {
      const name = el.getAttribute('data-name');
      const j = filtered.findIndex(x => x.name === name);
      if (j >= 0) show(j);
    });
  });
}
function applyFilter(){
  if (minFilter === null) {
    filtered = videos.slice();
  } else if (minFilter === 'unrated') {
    filtered = videos.filter(v => !v.score || v.score === 0);
  } else {
    filtered = videos.filter(v => (v.score||0) >= minFilter);
  }
  const info = document.getElementById('filter_info');
  let label;
  if (minFilter === null) {
    label = 'No filter';
  } else if (minFilter === 'unrated') {
    label = 'Unrated only';
  } else {
    label = 'rating ‚â• ' + minFilter;
  }
  info.textContent = `${label} ‚Äî showing ${filtered.length}/${videos.length}`;
}
function isVideoName(n){ return n.toLowerCase().endsWith('.mp4'); }
function isImageName(n){ const s=n.toLowerCase(); return s.endsWith('.png')||s.endsWith('.jpg')||s.endsWith('.jpeg'); }
function showMedia(url, name){
  const vtag = document.getElementById('player');
  const itag = document.getElementById('imgview');
  if (isVideoName(name)){
    itag.style.display = 'none'; itag.removeAttribute('src');
    vtag.style.display = ''; vtag.src = url + '#t=0.001';
  } else if (isImageName(name)){
    vtag.pause && vtag.pause(); vtag.removeAttribute('src'); vtag.load && vtag.load(); vtag.style.display='none';
    itag.style.display = ''; itag.src = url;
  } else {
    vtag.style.display='none'; vtag.removeAttribute('src');
    itag.style.display=''; itag.src = url;
  }
  const b1 = document.getElementById('extract_one'); const b2 = document.getElementById('extract_filtered');
  if (b1 && b2){ const enable = isVideoName(name); b1.disabled = !enable; b2.disabled = !enable; }
}
function show(i){
  if (filtered.length === 0){
    document.getElementById('filename').textContent = '(no items match filter)';
    const player = document.getElementById('player');
    player.removeAttribute('src'); player.load();
    renderScoreBar(0);
    updateDownloadButton(null);
    const controls = document.getElementById('pnginfo_controls'); if (controls) controls.style.display='none';
    const panel = document.getElementById('pnginfo_panel'); if (panel) panel.style.display='none';
    renderSidebar();
    return;
  }
  idx = Math.max(0, Math.min(i, filtered.length-1));
  const v = filtered[idx];
  showMedia(v.url, v.name);
  document.getElementById('filename').textContent = `${idx+1}/${filtered.length}  ‚Ä¢  ${v.name}`;
  fetch('/api/meta/' + encodeURIComponent(v.name))
    .then(r => r.ok ? r.json() : null)
    .then(meta => {
      if (meta && meta.width && meta.height) {
        document.getElementById('filename').textContent += ` [${meta.width}x${meta.height}]`;
      }
      setupPngInfo(meta, v.name);
    }).catch(()=>{ setupPngInfo(null, v.name); });

  updateDownloadButton(v.name);
  renderScoreBar(v.score || 0);
  renderSidebar();
}
// Function to estimate text width
function estimateTextWidth(text, element) {
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');
  const computedStyle = window.getComputedStyle(element);
  context.font = `${computedStyle.fontSize} ${computedStyle.fontFamily}`;
  return context.measureText(text).width;
}

// Function to resize directory input based on dir_display width
function resizeDirectoryInput() {
  const dirDisplay = document.getElementById('dir_display');
  const dirInput = document.getElementById('dir');
  const refreshBtn = document.getElementById('load');
  
  if (dirDisplay && dirInput && refreshBtn && dirDisplay.textContent) {
    const row = dirDisplay.closest('.row');
    if (!row) return;
    
    const rowWidth = row.offsetWidth;
    const displayWidth = dirDisplay.offsetWidth;
    
    // Calculate widths of other elements in the row
    const otherElements = row.querySelectorAll('button, input, select, .toggle-container');
    let otherElementsWidth = 0;
    
    otherElements.forEach(el => {
      if (el !== dirInput && el !== dirDisplay) {
        otherElementsWidth += el.offsetWidth;
      }
    });
    
    // Account for gaps (12px each) - count the number of direct children in the row
    const childCount = row.children.length;
    const gapWidth = (childCount - 1) * 12; // 12px gap between elements
    
    // Calculate available width for directory input
    // Row width - other elements - gaps - dir_display width - some padding
    const availableWidth = rowWidth - otherElementsWidth - gapWidth - displayWidth - 40; // 40px extra padding
    
    // Set reasonable bounds
    const minWidth = 200;
    const maxWidth = 600;
    const finalWidth = Math.max(minWidth, Math.min(availableWidth, maxWidth));
    
    dirInput.style.width = `${finalWidth}px`;
    dirInput.style.maxWidth = `${finalWidth}px`;
    
    console.log('Resize calculation:', {
      rowWidth,
      displayWidth,
      otherElementsWidth,
      gapWidth,
      availableWidth,
      finalWidth
    });
  }
}

async function loadVideos(){
  const res = await fetch("/api/videos");
  const data = await res.json();
  videos = data.videos || [];
  currentDir = data.dir || "";
  currentPattern = data.pattern || currentPattern;
  thumbnailsEnabled = data.thumbnails_enabled || false;
  thumbnailHeight = data.thumbnail_height || 64;
  toggleExtensions = data.toggle_extensions || ["jpg", "png", "mp4"];
  
  document.getElementById('dir_display').textContent = currentDir + '  ‚Ä¢  ' + currentPattern;
  const dirInput = document.getElementById('dir');
  if (dirInput && !dirInput.value) dirInput.value = currentDir;
  const patInput = document.getElementById('pattern');
  if (patInput && !patInput.value) patInput.value = currentPattern;
  
  // Resize directory input after updating dir_display
  resizeDirectoryInput();
  
  // Initialize toggle buttons
  initializeToggleButtons();
  
  // Show/hide thumbnail controls
  const sidebarControls = document.getElementById('sidebar_controls');
  if (sidebarControls) {
    sidebarControls.style.display = thumbnailsEnabled ? 'block' : 'none';
  }
  
  // Start monitoring thumbnail progress if thumbnails are enabled
  if (thumbnailsEnabled) {
    updateThumbnailStatus();
  }
  
  applyFilter();
  renderSidebar();
  show(0);
}
async function postScore(score){
  const v = filtered[idx];
  if (!v) return;
  await fetch('/api/score', {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify({ name: v.name, score: score })
  });
  const source = videos.find(x => x.name === v.name);
  if (source) source.score = score;
  v.score = score;
  const curName = v.name;
  applyFilter();
  const newIndex = filtered.findIndex(x => x.name === curName);
  if (newIndex >= 0) {
    show(newIndex);
  } else {
    show(idx);
  }
  renderSidebar();
}
async function postKey(key){
  const v = filtered[idx];
  await fetch("/api/key", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ key: key, name: v ? v.name : "" })
  });
}
async function scanDir(path){
  const pattern = (document.getElementById('pattern')?.value || '').trim();
  const res = await fetch("/api/scan", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ dir: path, pattern: pattern })
  });
  if (!res.ok){
    const t = await res.text();
    alert("Scan failed: " + t);
    return;
  }
  await loadVideos();
}
document.getElementById("pat_help").addEventListener("click", () => {
  alert("Glob syntax:\\n- Use * and ? wildcards (e.g., *.mp4, image??.png)\\n- Union with | (e.g., *.mp4|*.png|*.jpg)\\n- Examples:\\n  *.mp4\\n  image*.png\\n  *.mp4|*.png|*.jpg");
});
document.getElementById("load").addEventListener("click", () => {
  const path = (document.getElementById("dir").value || "").trim();
  if (path) {
    // Start monitoring thumbnail progress immediately if thumbnails are enabled
    if (thumbnailsEnabled) {
      updateThumbnailStatus();
    }
    scanDir(path);
  }
  // Resize directory input after refresh
  setTimeout(resizeDirectoryInput, 100); // Small delay to ensure DOM updates
});
document.getElementById('min_filter').addEventListener('change', () => {
  const val = document.getElementById('min_filter').value;
  if (val === 'none') {
    minFilter = null;
  } else if (val === 'unrated') {
    minFilter = 'unrated';
  } else {
    minFilter = parseInt(val);
  }
  fetch('/api/key', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ key: 'Filter=' + (minFilter===null?'none':(minFilter==='unrated'?'unrated':('>='+minFilter))), name: '' })});
  applyFilter(); renderSidebar(); show(0);
});
document.getElementById('dir').addEventListener('keydown', (e) => {
  if (e.key === "Enter"){
    const path = (document.getElementById("dir").value || "").trim();
    if (path) scanDir(path);
  }
});
document.getElementById('pattern').addEventListener('keydown', (e) => {
  if (e.key === "Enter"){
    const path = (document.getElementById("dir").value || "").trim();
    if (path) scanDir(path);
  }
});

// Directory navigation functions
async function goUpDirectory() {
  const dirInput = document.getElementById('dir');
  const currentPath = dirInput.value.trim();
  if (!currentPath) return;
  
  const path = new Path(currentPath);
  const parentPath = path.parent;
  if (parentPath && parentPath !== currentPath) {
    dirInput.value = parentPath;
    // Optionally trigger scan immediately
    // scanDir(parentPath);
  }
}

async function loadDirectories(basePath) {
  try {
    const response = await fetch(`/api/directories?path=${encodeURIComponent(basePath)}`);
    if (!response.ok) {
      throw new Error(`Failed to load directories: ${response.statusText}`);
    }
    const data = await response.json();
    return data.directories;
  } catch (error) {
    console.error('Error loading directories:', error);
    return [];
  }
}

function showDirectoryDropdown() {
  const dirInput = document.getElementById('dir');
  const dropdown = document.getElementById('dir_dropdown');
  const currentPath = dirInput.value.trim() || './';
  
  // Clear existing dropdown content
  dropdown.innerHTML = '<div class="dropdown-item" style="opacity: 0.6;">Loading...</div>';
  dropdown.style.display = 'block';
  
  loadDirectories(currentPath).then(directories => {
    dropdown.innerHTML = '';
    
    if (directories.length === 0) {
      dropdown.innerHTML = '<div class="dropdown-empty">No directories found</div>';
    } else {
      directories.forEach(dir => {
        const item = document.createElement('div');
        item.className = 'dropdown-item';
        item.textContent = dir.name;
        item.title = dir.path;
        item.addEventListener('click', () => {
          const currentValue = dirInput.value.trim();
          let newPath;
          if (currentValue.endsWith('/')) {
            newPath = currentValue + dir.name;
          } else {
            newPath = currentValue + '/' + dir.name;
          }
          dirInput.value = newPath;
          hideDirectoryDropdown();
        });
        dropdown.appendChild(item);
      });
    }
  }).catch(error => {
    dropdown.innerHTML = '<div class="dropdown-empty">Error loading directories</div>';
  });
}

function hideDirectoryDropdown() {
  const dropdown = document.getElementById('dir_dropdown');
  dropdown.style.display = 'none';
}

// Sibling directory functions
async function loadSiblingDirectories(currentPath) {
  try {
    const response = await fetch(`/api/sibling-directories?path=${encodeURIComponent(currentPath)}`);
    if (!response.ok) {
      throw new Error(`Failed to load sibling directories: ${response.statusText}`);
    }
    const data = await response.json();
    return data.directories;
  } catch (error) {
    console.error('Error loading sibling directories:', error);
    return [];
  }
}

function showSiblingDirectoryDropdown() {
  const dirInput = document.getElementById('dir');
  const dropdown = document.getElementById('dir_siblings_dropdown');
  const currentPath = dirInput.value.trim() || './';
  
  // Clear existing dropdown content
  dropdown.innerHTML = '<div class="dropdown-item" style="opacity: 0.6;">Loading...</div>';
  dropdown.style.display = 'block';
  
  loadSiblingDirectories(currentPath).then(directories => {
    dropdown.innerHTML = '';
    
    if (directories.length === 0) {
      dropdown.innerHTML = '<div class="dropdown-empty">No sibling directories found</div>';
    } else {
      directories.forEach(dir => {
        const item = document.createElement('div');
        item.className = 'dropdown-item';
        item.textContent = dir.name;
        item.title = dir.path;
        item.addEventListener('click', () => {
          dirInput.value = dir.path;
          hideSiblingDirectoryDropdown();
        });
        dropdown.appendChild(item);
      });
    }
  }).catch(error => {
    dropdown.innerHTML = '<div class="dropdown-empty">Error loading sibling directories</div>';
  });
}

function hideSiblingDirectoryDropdown() {
  const dropdown = document.getElementById('dir_siblings_dropdown');
  dropdown.style.display = 'none';
}

// Simple Path utility for JavaScript (since we don't have Node.js path module)
class Path {
  constructor(pathStr) {
    this.path = pathStr.replace(/\\/g, '/'); // Normalize to forward slashes
  }
  
  get parent() {
    const normalizedPath = this.path.replace(/\/+$/, ''); // Remove trailing slashes
    const lastSlash = normalizedPath.lastIndexOf('/');
    if (lastSlash <= 0) return '/';
    return normalizedPath.substring(0, lastSlash);
  }
}

// Add event listeners for directory navigation
document.getElementById('dir_up').addEventListener('click', goUpDirectory);
document.getElementById('dir_browse').addEventListener('click', showDirectoryDropdown);
document.getElementById('dir_siblings').addEventListener('click', showSiblingDirectoryDropdown);

// Hide dropdown when clicking outside
document.addEventListener('click', (e) => {
  const dropdownContainer = document.querySelector('.dir-dropdown-container');
  const dropdown = document.getElementById('dir_dropdown');
  const siblingContainer = document.querySelector('.dir-input-container');
  const siblingDropdown = document.getElementById('dir_siblings_dropdown');
  
  if (!dropdownContainer.contains(e.target)) {
    hideDirectoryDropdown();
  }
  
  if (!siblingContainer.contains(e.target)) {
    hideSiblingDirectoryDropdown();
  }
});

document.getElementById('prev').addEventListener('click', () => { show(idx-1); });
document.getElementById('next').addEventListener('click', () => { show(idx+1); });
document.getElementById("reject").addEventListener("click", () => { postScore(-1); });
document.getElementById("clear").addEventListener("click", () => { postScore(0); });
document.querySelectorAll("[data-star]").forEach(btn => {
  btn.addEventListener("click", () => {
    const n = parseInt(btn.getAttribute("data-star"));
    postScore(n);
  });
});
document.addEventListener("keydown", (e) => {
  if (["INPUT","TEXTAREA"].includes((e.target.tagName||"").toUpperCase())) return;
  const player = document.getElementById("player");
  function togglePlay(){ if (!player || player.style.display==='none') return; if (player.paused) { player.play(); } else { player.pause(); } }
  if (e.key === "Escape" && isMaximized){ e.preventDefault(); postKey("Escape"); toggleMaximize(); return; }
  if (e.key === "ArrowLeft"){ e.preventDefault(); postKey("ArrowLeft"); show(idx-1); return; }
  if (e.key === "ArrowRight"){ e.preventDefault(); postKey("ArrowRight"); show(idx+1); return; }
  if (e.key === " "){ e.preventDefault(); postKey("Space"); togglePlay(); return; }
  if (e.key === "1"){ e.preventDefault(); postKey("1"); postScore(1); return; }
  if (e.key === "2"){ e.preventDefault(); postKey("2"); postScore(2); return; }
  if (e.key === "3"){ e.preventDefault(); postKey("3"); postScore(3); return; }
  if (e.key === "4"){ e.preventDefault(); postKey("4"); postScore(4); return; }
  if (e.key === "5"){ e.preventDefault(); postKey("5"); postScore(5); return; }
  if (e.key === "r" || e.key === "R"){ e.preventDefault(); postKey("R"); postScore(-1); return; }
  if (e.key === "c" || e.key === "C"){ e.preventDefault(); postKey("C"); postScore(0); return; }
});
async function extractCurrent(){
  if (!filtered.length) { alert("No item selected."); return; }
  const v = filtered[idx];
  if (!v.name.toLowerCase().endsWith('.mp4')){ alert('Extractor only works for .mp4'); return; }
  try{
    const res = await fetch("/api/extract", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ names: [v.name] })
    });
    const data = await res.json();
    const ok = (data.results||[]).filter(r=>r.status==="ok").length;
    const err = (data.results||[]).length - ok;
    postKey("ExtractOne");
    alert(`Extracted: ${ok} OK, ${err} errors`);
  }catch(e){
    alert("Extraction failed: " + e);
  }
}
async function extractFiltered(){
  if (!filtered.length) { alert("No items in current filter scope."); return; }
  const names = filtered.map(v => v.name).filter(n => n.toLowerCase().endsWith('.mp4'));
  if (!names.length){ alert('No .mp4 files in the current filtered view.'); return; }
  try{
    const res = await fetch("/api/extract", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ names })
    });
    const data = await res.json();
    const ok = (data.results||[]).filter(r=>r.status==="ok").length;
    const err = (data.results||[]).length - ok;
    postKey("ExtractFiltered");
    alert(`Extracted: ${ok} OK, ${err} errors`);
  }catch(e){
    alert("Bulk extraction failed: " + e);
  }
}
async function exportFiltered(){
  if (!filtered.length) { alert("No items in current filter scope."); return; }
  const names = filtered.map(v => v.name);
  if (!names.length){ alert('No files in the current filtered view.'); return; }
  
  // Show progress
  showProgress('Exporting...');
  
  try{
    const res = await fetch("/api/export-filtered", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ names })
    });
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }
    // Create a blob from the response and trigger download
    const blob = await res.blob();
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    a.download = 'media.zip';
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
    postKey("ExportFiltered");
  }catch(e){
    alert("Export failed: " + e);
  } finally {
    // Hide progress
    hideProgress();
  }
}
document.getElementById("extract_one").addEventListener("click", extractCurrent);
document.getElementById("extract_filtered").addEventListener("click", extractFiltered);
document.getElementById("export_filtered_btn").addEventListener("click", exportFiltered);
window.addEventListener("load", loadVideos);
</script>
</body>
</html>
